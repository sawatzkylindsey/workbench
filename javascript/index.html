<!DOCTYPE html>
<meta charset="utf-8">
<style>

.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes circle {
  stroke: #fff;
  stroke-width: 1.5px;
}

.labels {
  font-family: "Helvetica Neue", Arial, sans-serif;
  font-size: 14px;
}

input {
  display: block;
  margin: 2px;
}
td {
  text-align: right;
}

</style>
<svg width="1200" height="700"></svg>
<!--<script src="https://d3js.org/d3.v4.min.js"></script>-->
<!--<script src="https://d3js.org/d3-selection-multi.v0.4.min.js"></script>-->
<script src="js/d3.min.js"></script>
<script src="js/d3-selection-multi.v0.4.min.js"></script>
<script src="js/jquery-3.2.1.min.js"></script>
<script src="js/rainbowvis.js"></script>
<script>

var rainbow = new Rainbow();
rainbow.setNumberRange(0, 1.0);
rainbow.setSpectrum("#96afff", "#001e84");

var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height");
var center_x = width / 2.0;
var center_y = height / 2.0;
var pool_radius = Math.min(width, height) / 2.5;
var pool = svg.append("circle")
    .style("stroke-width", 5)
    .style("stroke", "black")
    .style("fill", "white")
    .attrs({
        class: "pool",
        r: pool_radius,
        cx: 0,
        cy: 0,
        transform: "translate(" + center_x + "," + center_y + ")"
        //x: center_x,
        //y: center_y
    });

var controlFo = svg.append("foreignObject")
    .attr("id", "controlFo")
    .attr("transform", "translate(10, 10)")
    .attr("width", center_x - pool_radius - 40)
    .attr("height", height - 40);
$("#controlFo").load("controls.html");
function search(event) {
    if (event.keyCode == 13) {
        var searcher = $("#searcher");
        selectTerm(searcher.val());
        searcher.val("");
    }
}
var size = 1;
function resize(event) {
    console.log(event);
    size = event.target.valueAsNumber;
}

/*var textbox = controlFo.append("xhtml:input")
    .attr("type", "text")
    .attr("id", "textbox")
    .on("keydown", function () {
        if (d3.event.keyCode == 13) {
            selectTerm(textbox.property("value"));
            textbox.property("value", "");
        }
    });
var sizer = controlFo.append("xhtml:input")
    .attr("type", "range")
    .attr("id", "sizer")
    .attr("min", "1")
    .attr("max", "2000")
    .attr("value", "1")
    .on("input", function(e) {
        console.log(d3.event);
        size = d3.event.target.valueAsNumber;
        //size = event.value;
    })
    .on("change", function(e) {
        console.log(d3.event);
        size = d3.event.target.valueAsNumber;
        //svg.selectAll(".node")
        //    .enter()
        //    .attr("r", function(d) { return node_radius(d.rank); });
        //size = event.value;
    });*/
/*var release = controlFo.append("xhtml:input")
    .attr("type", "button")
    .text("release")
    .on("click", function(e) {
        console.log(d3.event);
        svg.selectAll(".node")
            .enter()
            .attr("fx", null)
            .attr("fy", null)
            .attr("drag", false);
    });*/

var summaryFo = svg.append("foreignObject")
    .attr("transform", "translate(" + (center_x - pool_radius) + "," + (center_y * 1.85) + ")")
    .attr("width", pool_radius * 2)
    .attr("height", 50);
var summary = summaryFo.append("xhtml:div")
    .attr("id", "summary")
    .attr("class", "labels")
    .style("text-align", "center")
    .text("placeholder");

var color = d3.scaleOrdinal(d3.schemeCategory20);
//var RADIUS_SCALE = 250;
var MIN_RADIUS = 5;
var MAX_RADIUS = 50;

function node_radius(rank) {
    return Math.min(Math.max(rank * size, MIN_RADIUS), MAX_RADIUS);
    /*if (rank < 0.009) {
        return 0.009 * RADIUS_SCALE;
    } else {
        return Math.min(rank * RADIUS_SCALE, MAX_RADIUS);
    }*/
}

var simulation = d3.forceSimulation()
    .force("link", d3.forceLink()
        .distance(80)
        //.strength(0.005)
        .id(function(d) { return d.name; })
    )
    .force("charge", d3.forceManyBody().strength(-100))
    /*.force("collide", d3.forceCollide(function (d) {
        return node_radius(d.rank) * 2;
    }).strength(0.005).iterations(16))*/
    //.force("center", d3.forceCenter(center_x, center_y))
    .force("x", d3.forceX(center_x).strength(0.05))
    .force("y", d3.forceY(center_y).strength(0.05));

d3.json("search")
    .post("", function(error, data) {
        //console.log(data);
        draw(data);
    });

function draw(graph) {
    console.log(graph);

    var previousPositions = {};
    svg.selectAll(".node")
        .each(function(n) {
            //console.log(n);
            previousPositions[n.name] = {x: n.x, y: n.y, drag: n.drag};
        });
    graph.nodes = graph.nodes.map(function(n) {
        if (n.name in previousPositions) {
            n.fx = previousPositions[n.name].x;
            n.fy = previousPositions[n.name].y;
            n.drag = previousPositions[n.name].drag;
        }
        return n;
    });
    console.log(graph);

    svg.selectAll("g").remove();
    /*summary.selectAll("ul").enter().remove();
    summary.append("ul")
        .selectAll("ul")
        .data(graph.summary)
        .enter()
            .append("li")
            .text(function(s) { return s; });*/
    summary.text(graph.summary);
    /*svg.selectAll("#summary").remove();
var summary = summaryFo.append("xhtml:div")
    .attr("id", "summary")
    .attr("class", "labels")
    .style("text-align", "center")
    .data(graph.summary)
    .enter()
        .append("ul")
        .append("li")
        .text("placeholder");*/

    var link = svg.append("g")
        .attr("class", "links")
        .selectAll("links")
        .data(graph.links, function (links) {
            return links;
        })
        .enter()
            .append("line")
            .attr("term-source", function(l) { return l.source; })
            .attr("term-target", function(l) { return l.target; })
            .attr("stroke-width", function(l) { return Math.sqrt(l.value); })
            .style("opacity", function(l) { return l.alpha; } );

    var node = svg.append("g")
        .attr("class", "nodes")
        .selectAll("bob")
        .data(graph.nodes)
        .enter()
            .append("circle")
            .attr("class", "node")
            .attr("id", function(d) { return "node-" + d.name; })
            .attr("fill", function(d) {
                return "#" + rainbow.colourAt(d.coeff);
            })
            .attr("term", function(d) { return d.name; })
            .attr("r", function(d) { return node_radius(d.rank); })
            .style("opacity", function(d) { return d.alpha; })
            .on("click", unstick)
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

    var labels = svg.append("g")
        .attr("class", "label")
        .selectAll("bobbobobo")
        .data(graph.nodes)
        .enter()
            .append("text")
            .style("pointer-events", "none")
            .attr("class", "labels")
            .attr("stroke", "black")
            .attr("term", function(d) { return d.name; })
            .style("opacity", function(d) { return d.alpha / 1.5; })
            .text(function (d) { return d.name; });

    simulation.nodes(graph.nodes)
        .on("tick", ticked);

    simulation.force("link")
        .links(graph.links);

    simulation.alphaTarget(0.5).restart();

    function ticked() {
        node.attrs(function(d) {
            var coordinates = pool_bound(node_radius(d.rank), d.x, d.y, d.drag);
            d.x = coordinates.x;
            d.y = coordinates.y;
            return {
                cx: coordinates.x,
                cy: coordinates.y,
                r: node_radius(d.rank)
            };
        });

        link.attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        labels.attrs(function(d) {
            var radius = node_radius(d.rank);
            return {
                x: d.x + 4.5 + radius,
                y: d.y + 4.5
            };
        });
    }
}

function xbounded(d) { return Math.max(Math.min(d.x, width - 50), 10); }
function ybounded(d) { return Math.max(Math.min(d.y, height - 10), 10); }

function pythagoras(x, y) {
    var distance_x = Math.abs(center_x - x);
    var distance_y = Math.abs(center_y - y);
    return {
        distance_x: distance_x,
        distance_y: distance_y,
        hypotenuse: Math.sqrt(Math.pow(distance_x, 2) + Math.pow(distance_y, 2))
    };
}

function pool_bound(radius, x, y, ignore) {
    var pyth = pythagoras(x, y);

    if (pyth.hypotenuse > pool_radius && !ignore) {
        var distance_total = pyth.distance_x + pyth.distance_y;
        var excess = pyth.hypotenuse - pool_radius;
        var excess_squared = Math.pow(excess, 2);
        var sign_x = x > center_x ? 1 : -1;
        var sign_y = y > center_y ? 1 : -1;
        return {
            x: x - (sign_x * Math.sqrt(excess_squared * (pyth.distance_x / distance_total))),
            y: y - (sign_y * Math.sqrt(excess_squared * (pyth.distance_y / distance_total)))
        };
    }
    else {
        return {x: x, y: y}
    }
}

function dragstarted(d) {
    if (!d3.event.active) {
        simulation.alphaTarget(0.3).restart();
    }
    d.fx = d.x;
    d.fy = d.y;
    d.drag = true;
    console.log(d);
}

function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
}

function dragended(d) {
    if (!d3.event.active) {
        simulation.alphaTarget(0);
    }

    var pyth = pythagoras(d.x, d.y);

    if (pyth.hypotenuse > pool_radius) {
        d3.json("positive")
            .post("term=" + d.name + "&mode=add", function(error, data) { console.log(data); } );
    } else {
        d3.json("positive")
            .post("term=" + d.name + "&mode=remove", function(error, data) { console.log(data); } );
    }
}

function unstick(d) {
    d.fx = null;
    d.fy = null;
    d.drag = false
    d3.json("positive")
        .post("term=" + d.name + "&mode=remove", function(error, data) { console.log(data); });
}

function selectTerm(termname) {
    console.log("term: " + termname);
    d3.json("search")
        .post("term=" + termname, function(error, data) {
            //console.log(data);
            draw(data);
        });
}
</script>

