<!DOCTYPE html>
<meta charset="utf-8">
<style>

.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes circle {
  stroke: #fff;
  stroke-width: 1.5px;
}

.labels {
  font-family: "Helvetica Neue", Arial, sans-serif;
  font-size: 14px;
}

</style>
<svg width="1200" height="700"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="rainbowvis.js"></script>
<script>

var rainbow = new Rainbow();
rainbow.setNumberRange(0, 1.0);
rainbow.setSpectrum("#96afff", "#001e84");

var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height");

var fo = svg.append("foreignObject")
    .attr("transform", "translate(20, 20)");

var textbox = fo.append("xhtml:input")
    .attr("type", "text")
    .attr("id", "textbox")
    .on("keydown", function () {
        if (d3.event.keyCode == 13) {
            selectTerm(textbox.property("value"));
            textbox.property("value", "");
        }
    });

var color = d3.scaleOrdinal(d3.schemeCategory20);
var RADIUS_SCALE = 250;

function radius(r) {
    if (r < 0.009) {
        return 0.009 * RADIUS_SCALE;
    } else {
        return r * RADIUS_SCALE;
    }
}

var simulation = d3.forceSimulation()
    .force("link", d3.forceLink()
        .distance(80)
        .id(function(d) { return d.name; })
    )
    .force("charge", d3.forceManyBody().strength(-200))
    .force("collide", d3.forceCollide(function (d) {
        return radius(d.radius) * 2;
    }).strength(0.005).iterations(16))
    //.force("center", d3.forceCenter(width / 2, height / 2))
    .force("y", d3.forceY(height / 2.0).strength(0.05))
    .force("x", d3.forceX(width/ 2.0).strength(0.05));

d3.json("search")
    .post("", function(error, data) {
        //console.log(data);
        draw(data);
    });


function draw(graph) {
    console.log(graph);

    var previousPositions = {};
    svg.selectAll("circle")
        .each(function(n) {
            //console.log(n);
            previousPositions[n.name] = {"x": n.x, "y": n.y};
        });
    graph.nodes = graph.nodes.map(function(n) {
        if (n.name in previousPositions) {
            n["fx"] = previousPositions[n.name].x;
            n["fy"] = previousPositions[n.name].y;
        }
        return n;
    });
    console.log(graph);

    svg.selectAll("g").remove();

    var link = svg.append("g")
        .attr("class", "links")
        .selectAll("links")
        .data(graph.links, function (links) {
            return links;
        })
        .enter()
        .append("line")
        .attr("term-source", function(l) { return l.source; })
        .attr("term-target", function(l) { return l.target; })
        .attr("stroke-width", function(l) { return Math.sqrt(l.value); })
        .style("opacity", function(l) { return l.alpha; } );

    var node = svg.append("g")
        .attr("class", "nodes")
        .selectAll("bob")
        .data(graph.nodes)
        .enter()
            .append("circle")
            .attr("id", function(d) { return "node-" + d.name; })
            .attr("fill", function(d) {
                return "#" + rainbow.colourAt(d.coeff);
            })
            .attr("term", function(d) { return d.name; })
            .attr("r", function(d) { return radius(d.radius); })
            .style("opacity", function(d) { return d.alpha; })
            .on("click", unstick)
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

    var labels = svg.append("g")
        .attr("class", "label")
        .selectAll("bobbobobo")
        .data(graph.nodes)
        .enter()
            .append("text")
            .style("pointer-events", "none")
            .attr("class", "labels")
            .attr("stroke", "black")
            .attr("term", function(d) { return d.name; })
            .style("opacity", function(d) { return d.alpha / 1.5; })
            .text(function (d) { return d.name; });

    simulation.nodes(graph.nodes)
        .on("tick", ticked);

    simulation.force("link")
        .links(graph.links);

    simulation.alphaTarget(0.5).restart();

    function ticked() {
        link
            .attr("x1", function(d) { return xbounded(d.source); })
            .attr("y1", function(d) { return ybounded(d.source); })
            .attr("x2", function(d) { return xbounded(d.target); })
            .attr("y2", function(d) { return ybounded(d.target); });

        node.attr("cx", function(d) { return xbounded(d);})
            .attr("cy", function(d) { return ybounded(d);});

        labels
            .attr("x", function(d) {
                return xbounded(d) + radius(d.radius) + 4.5;
            })
            .attr("y", function(d) { return ybounded(d) + 4.5; })
    }
}

function xbounded(d) { return Math.max(Math.min(d.x, width - 50), 10); }
function ybounded(d) { return Math.max(Math.min(d.y, height - 10), 10); }

function dragstarted(d) {
    if (!d3.event.active) {
        simulation.alphaTarget(0.3).restart();
    }
    d.fx = d.x;
    d.fy = d.y;
}

function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
}

function dragended(d) {
    if (!d3.event.active) {
        simulation.alphaTarget(0);
    }
}

function unstick(d) {
    d.fx = null;
    d.fy = null;
}

function selectTerm(termname) {
    console.log("term: " + termname);
    d3.json("search")
        .post(termname, function(error, data) {
            //console.log(data);
            draw(data);
        });
}
</script>

